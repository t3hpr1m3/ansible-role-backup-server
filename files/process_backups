#!/usr/bin/env bash

set -Eeuo pipefail

# set -x

source "${BACKUP_SERVER_LIB}/core.bash"

# # The name of our script
script_name=$(basename $0)

declare DRY_RUN=${DRY_RUN:-0}
declare PID_FILE=${PID_FILE:-/var/run/backups/backups.pid}

function usage {
	cat <<EOF

This script must be run with super-user privileges.

Usage: $script_name [-hnv] [-e PATTERN [-e PATTERN]] [-i FILE] [-k KEEP] [-m MODE] [-r host] [-u USER] host directory

Triggers a backup of the specified directory on the remote machine via rsync.

Available options:

	-h, --help             print this help and exit
	-n, --dry-run          perform a trial run (without actually executing the backup)
	-v, --verbose          print script debug info
	-c, --config=FILE      path to the configuration file (default: /etc/backups.conf)
	-e, --exclude=PATTERN  exclude files matching PATTERN
	-i, --identity=FILE    path to an identity file used to authenticate
	-k, --keep=COUNT       number of backups to keep
	-m, --mode=MODE        mode to operate in (DAILY, WEEKLY, MONTHLY, ANNUALLY)
	-u, --user=USER        remote user

EOF
}

function get_last_backup_run_time {
	declare -r status_file="$1"

	if [[ -f "${status_file}" ]]; then
		declare -r status_data=$(<${status_file})
		echo "${status_data}"
	else
		echo ""
	fi
}

function set_last_backup_run_time {
	declare -r status_file="$1"
	declare -ri seconds="$2"

	backups::log::debug "Updating timestamp in ${status_file} to ${seconds}"
	echo "${seconds}" >${status_file}
}

function is_backup_ready {
	declare -r status_file="$1"
	declare -r start_time="$2"
	declare -r frequency="$3"

	declare -r last_backup="$(get_last_backup_run_time "${status_file}")"
	if [[ -n "${last_backup}" ]]; then
		declare -i max_age=-1

		case "${frequency}" in
			hourly )
				max_age="$(date --date "1 hour ago" +%s)"
				;;
			daily )
				max_age="$(date --date "1 day ago" +%s)"
				;;
			weekly )
				max_age="$(date --date "1 week ago" +%s)"
				;;
			monthly )
				max_age="$(date --date "1 month ago" +%s)"
				;;
			yearly )
				max_age="$(date --date "1 year ago" +%s)"
				;;
		esac

		if [[ $last_backup -lt $max_age ]]; then
			echo "1"
		else
			echo "0"
		fi
	else
		echo "-1"
	fi
}

function execute_backup {
	declare -r name="$1"
	declare -r address="$2"
	declare -r user="$3"
	declare -r directory="$4"
	declare -r frequency="$5"
	declare -ri keep=$6

	shift 6
	declare -ra excludes="$@"

	declare -a backup_args=()

	backups::log::info \
		"Executing ${frequency} backup for ${name}[${directory}]"
	backups::log::debug \
		"${YELLOW}${name}${NOFORMAT}[${BLUE}${directory}${NOFORMAT}]:"
	backups::log::debug "  ${PURPLE}address${NOFORMAT}:   ${address}"

	if [[ -n "${user}" ]]; then
		backups::log::debug "  ${PURPLE}user${NOFORMAT}:      ${user}"
		backup_args+=(-u ${user})
	fi

	backups::log::debug "  ${PURPLE}keep${NOFORMAT}:      ${keep}"
	backup_args+=(-k ${keep})

	backups::log::debug "  ${PURPLE}frequency${NOFORMAT}: ${frequency}"
	backup_args=(-m ${frequency})

	if [[ ${#excludes[@]} -gt 0 ]]; then
		backups::log::debug "  ${PURPLE}excludes${NOFORMAT}:"
		for exclude in ${excludes[@]}; do
			backups::log::debug "    ${exclude}"
			backup_args+=(--exclude=$exclude)
		done
	fi

	backup_args+=(${address})
	backup_args+=(${directory})

	cmd="$(backups::utils::join_paths \
		$(backups::config::bin_dir) \
		"incremental_backup")"
	backups::log::debug \
		"  ${PURPLE}command${NOFORMAT}:   ${cmd} ${backup_args[*]}"
	# if [[ $DRY_RUN -eq 0 ]]; then
	# 	$cmd ${backup_args[*]}
	# fi
	backups::log::info \
		"Completed ${frequency} backup for ${name}[${directory}]"
}

function process_backup {
	declare -r name="$1"
	declare -r address="$2"
	declare -r user="$3"
	declare -r backup="$4"
	declare -a backup_args=()
	declare -ri start_time="$(date +%s)"

	declare -r directory="$(backups::json::get_string "${backup}" "directory")"
	declare -ri keep="$(backups::json::get_string "${backup}" "keep")"
	declare -r frequency="$(backups::json::get_string "${backup}" "frequency")"
	declare -ra excludes="$(backups::json::get_array "${backup}" "exclude")"

	[[ -z "$directory" ]] && backups::utils::error_exit \
		"<directory> is required for client [${name}]"
	[[ -z "$keep" ]] && backups::utils::error_exit \
		"<keep> is required for client [${name}]"
	[[ -z "$frequency" ]] && backups::utils::error_exit \
		"<frequency> is required for client [${name}]"

	backups::log::info \
		"Processing ${frequency} backup for ${name}[${directory}]"

	declare -r client_dir="$(backups::utils::join_paths \
		"$(backups::config::data_dir)" \
		"${name}" \
		"${directory}" \
	)"

	[[ ! -d "${client_dir}" ]] && mkdir -p "${client_dir}"
	declare -r status_file="$(backups::utils::join_paths \
		"${client_dir}" \
		".${frequency}.status" \
	)"

	declare -ri ready=$(is_backup_ready \
		"${status_file}" "${start_time}" "${frequency}" \
	)

	if [[ $ready -eq 0 ]]; then
		backups::log::info \
			"Skipping ${frequency} backup for ${name}[${directory}] (not ready)"
	else
		backups::log::info "ready: ${ready}"
		execute_backup \
			"${name}" "${address}" "${user}" "${directory}" "${frequency}" \
			"${keep}" "${excludes[*]}"
		backups::log::debug "Setting last run time to ${start_time}"
		backups::log::debug "DRY_RUN: ${DRY_RUN}"
		if [[ $DRY_RUN -eq 0 ]]; then
			backups::log::debug "Not a dry run"
			set_last_backup_run_time "${status_file}" "${start_time}"
		fi
	fi
}

function process_client {
	declare client="$1"
	declare -a backups=()

	declare -r name="$(backups::json::get_string "${client}" "name")"
	declare -r address="$(backups::json::get_string "${client}" "address")"
	declare -r user="$(backups::json::get_string "${client}" "user")"
	declare -ar backups=$(backups::json::get_array "${client}" "backups")

	[[ -z "$name" ]] && backups::utils::error_exit \
		"<name> is required"
	[[ -z "$address" ]] && backups::utils::error_exit \
		"<address> is required"
	[[ ${#backups[@]} -le 0 ]] && backups::utils::error_exit \
		"<backups> is required"

	for backup in ${backups[@]}; do
		process_backup "${name}" "${address}" "${user}" "${backup}"
	done
}

function process_args {
	while backups::parse_params "hn" "$@"; do
		shift $((OPTIND-1))

		case "$OPT" in
			h | help)
				usage
				exit 1
				;;
			n | dry-run)
				DRY_RUN=1
				;;
			* )
				usage
				;;
		esac
	done
}

function cleanup {
	backups::clear_pid "${PID_FILE}"
	trap - SIGINT SIGTERM ERR EXIT
}

function main {
	declare -i pid

	process_args "$@"
	backups::init
	backups::config::init

	PID_FILE="$(backups::utils::join_paths \
		"$(backups::config::run_dir)" "backups.pid")"

	pid=$(backups::check_pid "${PID_FILE}")
	[[ $pid -gt 0 ]] && exit 1
	backups::update_pid "${PID_FILE}" "$$"

	trap cleanup SIGINT SIGTERM ERR EXIT

	backups::log::init "$(backups::config::log_dir)" "backups.log"
	backups::log::info "Backup starting..."

	declare -ra clients=$(backups::config::clients)
	for client in ${clients[@]}; do
		process_client "${client}"
	done
	backups::log::debug "Exiting"
}

main "$@"

# vim: filetype=sh ts=4 sts=4 sw=4 noet
